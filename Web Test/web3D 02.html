<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ‰ ç³–æœå°é¾™å¤§å†’é™©</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>ğŸ‰ ç³–æœå°é¾™å¤§å†’é™©</header>
    <div class="controls">
        ä½¿ç”¨ <b>W A S D</b> é”®å¼•å¯¼å°é¾™æ”¶é›†ç³–æœï¼
    </div>

    <!-- åˆ†æ•°æ˜¾ç¤º -->
    <div id="score">åˆ†æ•°: 0</div>

    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="bg-music" src="./Assets/èƒŒæ™¯éŸ³ä¹.MP3" loop></audio>
    <script>
        const bgMusic = document.getElementById("bg-music");
        bgMusic.play().catch(() => {
            alert("æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·ç‚¹å‡»é¡µé¢å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹ã€‚");
            const startMusic = () => {
                bgMusic.play();
                document.body.removeEventListener("click", startMusic);
            };
            document.body.addEventListener("click", startMusic);
        });
    </script>

    <script type="module">
        import * as THREE from "./lib/three.module.js";
        import { GLTFLoader } from "./lib/GLTFLoader.js";

        let mesh, mixer;
        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const d = 1.5;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(0.25, -0.1, 2);
        camera.lookAt(0.1, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // åŠ è½½å°é¾™æ¨¡å‹
        const loader = new GLTFLoader();
        loader.load("./Assets/Cute_Dragon.glb", gltf => {
            mesh = gltf.scene;
            mesh.scale.set(0.5, 0.5, 0.5);
            scene.add(mesh);

            if (gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(mesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
            }
        });

        // é”®ç›˜æ§åˆ¶
        let up = false, down = false, left = false, right = false;
        document.addEventListener("keydown", e => {
            if (e.keyCode === 87) up = true;
            if (e.keyCode === 83) down = true;
            if (e.keyCode === 65) left = true;
            if (e.keyCode === 68) right = true;
        });
        document.addEventListener("keyup", e => {
            if (e.keyCode === 87) up = false;
            if (e.keyCode === 83) down = false;
            if (e.keyCode === 65) left = false;
            if (e.keyCode === 68) right = false;
        });

        // çª—å£ç¼©æ”¾
        window.addEventListener("resize", () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === äº”é¢œå…­è‰²ç³–æœçƒç³»ç»Ÿ ===
        const collectibles = [];
        const collectibleCount = 5;
        const collectibleRadius = 0.08;
        const candyColors = [0xff4d4d, 0xffb84d, 0xffff4d, 0x4dff4d, 0x4dffff, 0x4d4dff, 0xff4dff];

        function createCollectible() {
            const geometry = new THREE.SphereGeometry(collectibleRadius, 32, 32);
            const color = candyColors[Math.floor(Math.random() * candyColors.length)];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.5,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.x = (Math.random() * 2 - 1) * d * aspect * 0.8;
            sphere.position.y = (Math.random() * 2 - 1) * d * 0.8;
            scene.add(sphere);
            collectibles.push(sphere);
        }

        for (let i = 0; i < collectibleCount; i++) {
            createCollectible();
        }

        let score = 0;
        const scoreDiv = document.getElementById("score");
        // åˆ›å»ºéŸ³æ•ˆå¯¹è±¡
        const collectSound = new Audio("./Assets/æ”¶é›†éŸ³æ•ˆ.MP3");

        // åœ¨ checkCollectibles å‡½æ•°é‡Œï¼Œæ¯æ¬¡æ”¶é›†æ—¶æ’­æ”¾éŸ³æ•ˆ
        function checkCollectibles() {
            if (!mesh) return;
            collectibles.forEach(c => {
                const dx = mesh.position.x - c.position.x;
                const dy = mesh.position.y - c.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 0.3) {
                    // æ”¶é›†åéšæœºæ–°ä½ç½®å¹¶åˆ·æ–°é¢œè‰²
                    const color = candyColors[Math.floor(Math.random() * candyColors.length)];
                    c.material.color.setHex(color);
                    c.material.emissive.setHex(color);
                    c.position.x = (Math.random() * 2 - 1) * d * aspect * 0.8;
                    c.position.y = (Math.random() * 2 - 1) * d * 0.8;

                    // æ’­æ”¾éŸ³æ•ˆ
                    collectSound.currentTime = 0; // é¿å…éŸ³æ•ˆå åŠ å»¶è¿Ÿ
                    collectSound.play();

                    score++;
                    scoreDiv.textContent = "åˆ†æ•°: " + score;
                }
            });
        }

        // æ¸²æŸ“å¾ªç¯
        function renderScene() {
            requestAnimationFrame(renderScene);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);

            if (!mesh) return;

            const speed = 0.02;
            if (up) mesh.position.y += speed;
            if (down) mesh.position.y -= speed;
            if (left) mesh.position.x -= speed;
            if (right) mesh.position.x += speed;

            const aspect = window.innerWidth / window.innerHeight;
            const halfWidth = d * aspect;
            const halfHeight = d;
            const margin = 0.1;
            const meshHalfWidth = 0.25;
            const meshHalfHeight = 0.25;
            mesh.position.x = Math.min(Math.max(mesh.position.x, -halfWidth + margin + meshHalfWidth), halfWidth - margin - meshHalfWidth);
            mesh.position.y = Math.min(Math.max(mesh.position.y, -halfHeight + margin + meshHalfHeight), halfHeight - margin - meshHalfHeight);

            checkCollectibles();
            // å¤§å°ä¸Šä¸‹æ‘†åŠ¨ å‘¼å¸åŠ¨ç”»
            collectibles.forEach((c, index) => {
                const scale = 1 + Math.sin(clock.getElapsedTime() * 3 + index) * 0.2;
                c.scale.set(scale, scale, scale);
            });

        }

        renderScene();
    </script>
</body>

</html>