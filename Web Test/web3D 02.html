<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🐉 糖果小龙大冒险</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>🐉 糖果小龙大冒险</header>
    <div class="controls">
        使用 <b>W A S D</b> 键引导小龙收集糖果！
    </div>

    <!-- 分数显示 -->
    <div id="score">分数: 0</div>

    <!-- 背景音乐 -->
    <audio id="bg-music" src="./Assets/背景音乐.MP3" loop></audio>
    <script>
        const bgMusic = document.getElementById("bg-music");
        bgMusic.play().catch(() => {
            alert("浏览器阻止了自动播放，请点击页面开始播放背景音乐。");
            const startMusic = () => {
                bgMusic.play();
                document.body.removeEventListener("click", startMusic);
            };
            document.body.addEventListener("click", startMusic);
        });
    </script>

    <script type="module">
        import * as THREE from "./lib/three.module.js";
        import { GLTFLoader } from "./lib/GLTFLoader.js";

        let mesh, mixer;
        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const d = 1.5;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(0.25, -0.1, 2);
        camera.lookAt(0.1, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // 加载小龙模型
        const loader = new GLTFLoader();
        loader.load("./Assets/Cute_Dragon.glb", gltf => {
            mesh = gltf.scene;
            mesh.scale.set(0.5, 0.5, 0.5);
            scene.add(mesh);

            if (gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(mesh);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
            }
        });

        // 键盘控制
        let up = false, down = false, left = false, right = false;
        document.addEventListener("keydown", e => {
            if (e.keyCode === 87) up = true;
            if (e.keyCode === 83) down = true;
            if (e.keyCode === 65) left = true;
            if (e.keyCode === 68) right = true;
        });
        document.addEventListener("keyup", e => {
            if (e.keyCode === 87) up = false;
            if (e.keyCode === 83) down = false;
            if (e.keyCode === 65) left = false;
            if (e.keyCode === 68) right = false;
        });

        // 窗口缩放
        window.addEventListener("resize", () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === 五颜六色糖果球系统 ===
        const collectibles = [];
        const collectibleCount = 5;
        const collectibleRadius = 0.08;
        const candyColors = [0xff4d4d, 0xffb84d, 0xffff4d, 0x4dff4d, 0x4dffff, 0x4d4dff, 0xff4dff];

        function createCollectible() {
            const geometry = new THREE.SphereGeometry(collectibleRadius, 32, 32);
            const color = candyColors[Math.floor(Math.random() * candyColors.length)];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.5,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.x = (Math.random() * 2 - 1) * d * aspect * 0.8;
            sphere.position.y = (Math.random() * 2 - 1) * d * 0.8;
            scene.add(sphere);
            collectibles.push(sphere);
        }

        for (let i = 0; i < collectibleCount; i++) {
            createCollectible();
        }

        let score = 0;
        const scoreDiv = document.getElementById("score");
        // 创建音效对象
        const collectSound = new Audio("./Assets/收集音效.MP3");

        // 在 checkCollectibles 函数里，每次收集时播放音效
        function checkCollectibles() {
            if (!mesh) return;
            collectibles.forEach(c => {
                const dx = mesh.position.x - c.position.x;
                const dy = mesh.position.y - c.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 0.3) {
                    // 收集后随机新位置并刷新颜色
                    const color = candyColors[Math.floor(Math.random() * candyColors.length)];
                    c.material.color.setHex(color);
                    c.material.emissive.setHex(color);
                    c.position.x = (Math.random() * 2 - 1) * d * aspect * 0.8;
                    c.position.y = (Math.random() * 2 - 1) * d * 0.8;

                    // 播放音效
                    collectSound.currentTime = 0; // 避免音效叠加延迟
                    collectSound.play();

                    score++;
                    scoreDiv.textContent = "分数: " + score;
                }
            });
        }

        // 渲染循环
        function renderScene() {
            requestAnimationFrame(renderScene);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            renderer.render(scene, camera);

            if (!mesh) return;

            const speed = 0.02;
            if (up) mesh.position.y += speed;
            if (down) mesh.position.y -= speed;
            if (left) mesh.position.x -= speed;
            if (right) mesh.position.x += speed;

            const aspect = window.innerWidth / window.innerHeight;
            const halfWidth = d * aspect;
            const halfHeight = d;
            const margin = 0.1;
            const meshHalfWidth = 0.25;
            const meshHalfHeight = 0.25;
            mesh.position.x = Math.min(Math.max(mesh.position.x, -halfWidth + margin + meshHalfWidth), halfWidth - margin - meshHalfWidth);
            mesh.position.y = Math.min(Math.max(mesh.position.y, -halfHeight + margin + meshHalfHeight), halfHeight - margin - meshHalfHeight);

            checkCollectibles();
            // 大小上下摆动 呼吸动画
            collectibles.forEach((c, index) => {
                const scale = 1 + Math.sin(clock.getElapsedTime() * 3 + index) * 0.2;
                c.scale.set(scale, scale, scale);
            });

        }

        renderScene();
    </script>
</body>

</html>